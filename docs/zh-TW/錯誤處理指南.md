# 錯誤處理指南

全面的錯誤處理指南，幫助您在使用 SpringMVC Agent Analyzer 時優雅地處理各種錯誤情況。

## 📋 目錄

1. [概述](#概述)
2. [錯誤格式系統](#錯誤格式系統)
3. [常見錯誤類型](#常見錯誤類型)
4. [使用範例](#使用範例)
5. [進階功能](#進階功能)
6. [最佳實踐](#最佳實踐)
7. [自訂錯誤處理](#自訂錯誤處理)
8. [故障排除](#故障排除)

---

## 概述

SpringMVC Agent Analyzer 使用**標準化錯誤格式系統** (`ErrorFormatter`) 提供一致、詳細的錯誤訊息，幫助您快速定位和解決問題。

### 為什麼需要標準化錯誤格式？

**❌ 傳統錯誤訊息：**
```python
# 不一致、難以理解
raise Exception("Error in file")
raise ValueError(f"Invalid: {value}")
print(f"Failed: {error}")  # 不同格式
```

**✅ 標準化錯誤訊息：**
```python
# 一致、詳細、可操作
error_msg = ErrorFormatter.format_error_message(
    error_type="FileNotFoundError",
    component="file_processor",
    details="無法讀取檔案",
    context={"file_path": path, "reason": "檔案不存在"},
    suggestions=["檢查檔案路徑", "確認檔案權限"]
)
```

### 錯誤訊息結構

所有錯誤遵循一致的結構：

```
[錯誤類型] 元件名稱: 詳細說明

Context:
  - 鍵1: 值1
  - 鍵2: 值2

Suggestions:
  - 建議 1
  - 建議 2
```

---

## 錯誤格式系統

### 快速開始（30 秒）

```python
from sdk_agent.error_formatter import ErrorFormatter

# 基本錯誤訊息
error_msg = ErrorFormatter.format_error_message(
    error_type="ValueError",
    component="my_module",
    details="輸入值無效",
    context={"input": user_input, "expected": "正整數"},
    suggestions=["檢查輸入格式", "只使用正整數"]
)
print(error_msg)
```

**輸出：**
```
[ValueError] my_module: 輸入值無效

Context:
  - input: -5
  - expected: 正整數

Suggestions:
  - 檢查輸入格式
  - 只使用正整數
```

### 核心 API

`ErrorFormatter` 類別提供以下方法：

| 方法 | 用途 | 適用場景 |
|------|------|----------|
| `format_error_message()` | 通用錯誤格式化 | 任何錯誤情況 |
| `format_file_error()` | 檔案操作錯誤 | 讀寫檔案失敗 |
| `format_validation_error()` | 驗證錯誤 | 輸入驗證失敗 |
| `format_configuration_error()` | 設定錯誤 | 設定參數無效 |
| `format_processing_error()` | 處理錯誤 | 批次處理失敗 |

---

## 常見錯誤類型

### 1. 檔案操作錯誤

當檔案讀寫操作失敗時使用。

**範例：**

```python
from sdk_agent.error_formatter import ErrorFormatter

try:
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
except FileNotFoundError as e:
    error_msg = ErrorFormatter.format_file_error(
        file_path="UserController.java",
        error=e,
        operation="read",
        suggestions=[
            "檢查檔案是否存在",
            "確認檔案路徑正確",
            "驗證檔案權限可讀"
        ]
    )
    raise FileNotFoundError(error_msg) from e
```

**輸出：**
```
[FileNotFoundError] file_operation: 無法讀取檔案

Context:
  - file_path: UserController.java
  - error_message: [Errno 2] No such file or directory: 'UserController.java'

Suggestions:
  - 檢查檔案是否存在
  - 確認檔案路徑正確
  - 驗證檔案權限可讀
```

**常見檔案錯誤：**

| 錯誤類型 | 原因 | 解決方案 |
|----------|------|----------|
| `FileNotFoundError` | 檔案不存在 | 檢查路徑，使用絕對路徑 |
| `PermissionError` | 權限不足 | 修改檔案權限（chmod） |
| `IsADirectoryError` | 路徑是目錄 | 確認路徑指向檔案 |
| `UnicodeDecodeError` | 編碼錯誤 | 指定正確編碼（utf-8） |

### 2. 驗證錯誤

當輸入參數驗證失敗時使用。

**範例：**

```python
from sdk_agent.error_formatter import ErrorFormatter

def validate_batch_size(batch_size: int):
    """驗證批次大小"""
    if batch_size < 1:
        error_msg = ErrorFormatter.format_validation_error(
            field_name="batch_size",
            value=batch_size,
            expected="必須 >= 1",
            suggestions=[
                "使用至少為 1 的批次大小",
                "建議：10-50 以獲得最佳效能"
            ]
        )
        raise ValueError(error_msg)

# 使用
try:
    validate_batch_size(0)
except ValueError as e:
    print(e)
```

**輸出：**
```
[ValidationError] validation: 'batch_size' 的值無效

Context:
  - field: batch_size
  - provided: 0
  - expected: 必須 >= 1

Suggestions:
  - 使用至少為 1 的批次大小
  - 建議：10-50 以獲得最佳效能
```

### 3. 設定錯誤

當設定參數無效時使用。

**範例：**

```python
from sdk_agent.error_formatter import ErrorFormatter

def validate_config(max_concurrency: int):
    """驗證並行數設定"""
    if not (1 <= max_concurrency <= 100):
        error_msg = ErrorFormatter.format_configuration_error(
            parameter="max_concurrency",
            value=max_concurrency,
            valid_range="1-100",
            suggestions=[
                "設定 max_concurrency 在 1 到 100 之間",
                "建議：5-10 以獲得最佳效能"
            ]
        )
        raise ValueError(error_msg)

# 使用
try:
    validate_config(200)
except ValueError as e:
    print(e)
```

**輸出：**
```
[ConfigurationError] configuration: 設定參數 'max_concurrency' 無效

Context:
  - parameter: max_concurrency
  - provided_value: 200
  - valid_range: 1-100

Suggestions:
  - 設定 max_concurrency 在 1 到 100 之間
  - 建議：5-10 以獲得最佳效能
```

### 4. 批次處理錯誤

當批次處理失敗時使用。

**範例：**

```python
from pathlib import Path
from sdk_agent.error_formatter import ErrorFormatter

async def process_file(file_path: Path, batch_num: int, total_batches: int):
    """處理單一檔案"""
    try:
        # 處理檔案...
        result = await analyzer.analyze_file(str(file_path))
        return {"success": True, "result": result}

    except Exception as e:
        error_msg = ErrorFormatter.format_processing_error(
            item=str(file_path),
            error=e,
            batch_info={
                "batch": batch_num,
                "total_batches": total_batches,
                "files_in_batch": 20
            }
        )
        return {"success": False, "error": error_msg}
```

**輸出：**
```
[ProcessingError] batch_processor: 處理項目失敗

Context:
  - item: /path/to/UserController.java
  - error_type: ValueError
  - error_message: Invalid Java syntax on line 45
  - batch: 3
  - total_batches: 10
  - files_in_batch: 20

Suggestions:
  - 檢查項目是否存在且可存取
  - 確認項目格式正確
  - 查看日誌以獲取詳細錯誤資訊
```

---

## 使用範例

### 範例 1: 完整的檔案分析錯誤處理

```python
from pathlib import Path
from sdk_agent.client import SpringMVCAnalyzerAgent
from sdk_agent.error_formatter import ErrorFormatter
from sdk_agent.exceptions import SDKAgentError

async def safe_analyze_file(file_path: str):
    """安全的檔案分析（含完整錯誤處理）"""

    # 步驟 1: 驗證檔案存在
    path = Path(file_path)
    if not path.exists():
        error_msg = ErrorFormatter.format_file_error(
            file_path=file_path,
            error=FileNotFoundError(f"檔案不存在: {file_path}"),
            operation="analyze",
            suggestions=[
                f"確認檔案存在於: {path.absolute()}",
                "使用絕對路徑而非相對路徑",
                "檢查檔案名稱拼寫"
            ]
        )
        return {"success": False, "error": error_msg}

    # 步驟 2: 驗證檔案可讀
    if not path.is_file():
        error_msg = ErrorFormatter.format_file_error(
            file_path=file_path,
            error=IsADirectoryError(f"路徑是目錄: {file_path}"),
            operation="analyze",
            suggestions=[
                "確認路徑指向檔案而非目錄",
                f"使用: {path}/YourFile.java"
            ]
        )
        return {"success": False, "error": error_msg}

    # 步驟 3: 執行分析
    try:
        agent = SpringMVCAnalyzerAgent()
        result = await agent.analyze_file(file_path)

        return {"success": True, "result": result}

    except SDKAgentError as e:
        error_msg = ErrorFormatter.format_processing_error(
            item=file_path,
            error=e,
            batch_info={"stage": "analysis"}
        )
        return {"success": False, "error": error_msg}

    except Exception as e:
        error_msg = ErrorFormatter.format_error_message(
            error_type=type(e).__name__,
            component="file_analyzer",
            details=f"分析檔案時發生未預期的錯誤",
            context={
                "file_path": file_path,
                "error_message": str(e)
            },
            suggestions=[
                "查看詳細日誌",
                "確認檔案格式正確",
                "嘗試分析較小的檔案",
                "回報此問題到 GitHub Issues"
            ]
        )
        return {"success": False, "error": error_msg}

# 使用範例
result = await safe_analyze_file("src/main/java/UserController.java")

if result['success']:
    print("✅ 分析成功")
    print(result['result'])
else:
    print("❌ 分析失敗")
    print(result['error'])
```

### 範例 2: 批次處理含錯誤恢復

```python
from sdk_agent.error_formatter import ErrorFormatter
import logging

logger = logging.getLogger(__name__)

async def robust_batch_analysis(file_paths: list[str]):
    """強健的批次分析（含錯誤恢復）"""

    results = []
    errors = []

    for i, file_path in enumerate(file_paths, 1):
        print(f"處理 [{i}/{len(file_paths)}]: {file_path}")

        try:
            result = await safe_analyze_file(file_path)

            if result['success']:
                results.append(result['result'])
                print("  ✅ 成功")
            else:
                errors.append({
                    "file": file_path,
                    "error": result['error']
                })
                print(f"  ❌ 失敗")
                logger.error(result['error'])

        except Exception as e:
            # 即使單一檔案失敗，繼續處理其他檔案
            error_msg = ErrorFormatter.format_processing_error(
                item=file_path,
                error=e,
                batch_info={
                    "current": i,
                    "total": len(file_paths)
                }
            )
            errors.append({
                "file": file_path,
                "error": error_msg
            })
            logger.error(error_msg)
            print(f"  ⚠️  例外狀況，繼續處理...")

    # 產生摘要報告
    print("\n" + "="*60)
    print(f"批次處理完成:")
    print(f"  成功: {len(results)}/{len(file_paths)}")
    print(f"  失敗: {len(errors)}/{len(file_paths)}")

    if errors:
        print(f"\n失敗的檔案:")
        for err in errors:
            print(f"  - {err['file']}")

    return {
        "results": results,
        "errors": errors,
        "success_rate": len(results) / len(file_paths) * 100
    }

# 使用範例
files = [
    "Controller1.java",
    "Controller2.java",
    "Controller3.java"
]

report = await robust_batch_analysis(files)

if report['success_rate'] == 100:
    print("\n🎉 所有檔案分析成功！")
elif report['success_rate'] >= 80:
    print(f"\n✅ 大部分成功 ({report['success_rate']:.1f}%)")
else:
    print(f"\n⚠️  成功率較低 ({report['success_rate']:.1f}%)，請檢查錯誤")
```

### 範例 3: 結構化日誌記錄

```python
from sdk_agent.error_formatter import log_structured_error
import logging

# 設定日誌
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('analyzer.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

async def logged_analysis(file_path: str):
    """帶結構化日誌的分析"""

    try:
        agent = SpringMVCAnalyzerAgent()
        result = await agent.analyze_file(file_path)

        logger.info(f"成功分析: {file_path}")
        return result

    except FileNotFoundError as e:
        # 使用結構化錯誤日誌
        log_structured_error(
            logger_obj=logger,
            error=e,
            component="file_analyzer",
            context={
                "operation": "analyze_file",
                "file_path": file_path,
                "file_exists": Path(file_path).exists()
            },
            level=logging.ERROR
        )
        raise

    except Exception as e:
        log_structured_error(
            logger_obj=logger,
            error=e,
            component="file_analyzer",
            context={
                "operation": "analyze_file",
                "file_path": file_path
            },
            level=logging.CRITICAL
        )
        raise
```

---

## 進階功能

### 1. 上下文截斷

大型上下文值會自動截斷，防止日誌過長：

```python
from sdk_agent.error_formatter import ErrorFormatter

# 大型資料會自動處理
large_data = "x" * 10000  # 10,000 個字元

error_msg = ErrorFormatter.format_error_message(
    error_type="DataError",
    component="data_processor",
    details="處理大型資料集失敗",
    context={
        "data": large_data,  # 會截斷到 500 字元
        "rows": 1000000
    }
)

print(error_msg)
```

**輸出：**
```
[DataError] data_processor: 處理大型資料集失敗

Context:
  - data: xxxxx... [truncated]
  - rows: 1000000
```

**截斷規則：**
- 單一值最大長度：**500 字元**
- 總上下文最大長度：**2000 字元**

### 2. 可配置的截斷限制

根據需求調整截斷限制：

```python
from sdk_agent.error_formatter import ErrorFormatter

# 預設限制（500/2000）
error_msg = ErrorFormatter.format_error_message(
    error_type="Error",
    component="component",
    details="詳細說明",
    context=large_context
)

# 自訂限制
error_msg = ErrorFormatter.format_error_message(
    error_type="Error",
    component="component",
    details="詳細說明",
    context=large_context,
    max_context_value_length=1000,  # 每個值 1000 字元
    max_total_context_length=5000   # 總共 5000 字元
)

# 詳細模式（無截斷）
error_msg = ErrorFormatter.format_error_message(
    error_type="Error",
    component="component",
    details="詳細說明",
    context=large_context,
    max_context_value_length=-1,    # -1 = 停用截斷
    max_total_context_length=-1
)
```

### 3. 截斷日誌追蹤

追蹤截斷事件以進行監控：

```python
import logging
from sdk_agent.error_formatter import ErrorFormatter

# 設定 DEBUG 層級以查看截斷日誌
logging.basicConfig(level=logging.DEBUG)

logger = logging.getLogger('sdk_agent.error_formatter')

# 當發生截斷時，會記錄 DEBUG 訊息
error_msg = ErrorFormatter.format_error_message(
    error_type="Error",
    component="component",
    details="詳細說明",
    context={"large_data": "x" * 1000}
)

# DEBUG 輸出:
# Truncated context value: 'large_data' (original: 1000 chars, limit: 500)
```

### 4. 型別別名

使用型別別名提高程式碼可讀性：

```python
from sdk_agent.error_formatter import ErrorContext, SuggestionList

def my_error_handler(
    context: ErrorContext,      # Dict[str, Any]
    suggestions: SuggestionList  # List[str]
) -> str:
    """自訂錯誤處理器"""
    return ErrorFormatter.format_error_message(
        error_type="CustomError",
        component="my_component",
        details="發生錯誤",
        context=context,
        suggestions=suggestions
    )

# 使用
error_msg = my_error_handler(
    context={"file": "test.java", "line": 42},
    suggestions=["檢查語法", "確認引入"]
)
```

---

## 最佳實踐

### 1. 總是提供上下文

上下文資訊對診斷問題至關重要。

**❌ 不好的做法：**
```python
# 缺乏上下文
error_msg = ErrorFormatter.format_error_message(
    error_type="ProcessingError",
    component="processor",
    details="處理失敗"
)
```

**✅ 好的做法：**
```python
# 提供豐富的上下文
error_msg = ErrorFormatter.format_error_message(
    error_type="ProcessingError",
    component="processor",
    details="處理檔案失敗",
    context={
        "file_path": file_path,
        "file_size": file_size,
        "encoding": encoding,
        "line_number": line_num,
        "operation": "parse_annotations"
    }
)
```

### 2. 提供可操作的建議

建議應該具體且可執行。

**❌ 模糊的建議：**
```python
suggestions=["修復錯誤", "再試一次"]
```

**✅ 具體的建議：**
```python
suggestions=[
    "確認檔案存在於: /path/to/file",
    "檢查檔案權限（應該可讀）: chmod +r file.java",
    "驗證檔案編碼為 UTF-8: file -i file.java"
]
```

### 3. 使用適當的錯誤類型

選擇最具體的錯誤類型。

**❌ 不夠具體：**
```python
error_type="Error"  # 太通用
```

**✅ 具體明確：**
```python
error_type="FileNotFoundError"      # 檔案不存在
error_type="ValidationError"        # 驗證失敗
error_type="ConfigurationError"     # 設定錯誤
error_type="ProcessingError"        # 處理錯誤
```

### 4. 使用專門的格式化方法

盡可能使用專門的格式化方法。

**❌ 使用通用方法：**
```python
error_msg = ErrorFormatter.format_error_message(
    error_type="FileNotFoundError",
    component="file_operation",
    details="找不到檔案",
    context={"file": path}
)
```

**✅ 使用專門方法：**
```python
error_msg = ErrorFormatter.format_file_error(
    file_path=path,
    error=FileNotFoundError("找不到檔案"),
    operation="read"
)
```

### 5. 結構化日誌記錄

始終使用結構化日誌以保持一致性。

**❌ 基本日誌：**
```python
logger.error(f"{component} 發生錯誤: {str(error)}")
```

**✅ 結構化日誌：**
```python
log_structured_error(
    logger_obj=logger,
    error=error,
    component=component,
    context={"additional": "info"}
)
```

### 6. 錯誤恢復策略

實作漸進式錯誤恢復：

```python
async def resilient_analyze(file_path: str, max_retries: int = 3):
    """具有重試機制的分析"""

    for attempt in range(1, max_retries + 1):
        try:
            result = await agent.analyze_file(file_path)
            return {"success": True, "result": result}

        except Exception as e:
            if attempt == max_retries:
                # 最後一次嘗試，記錄並回報錯誤
                error_msg = ErrorFormatter.format_processing_error(
                    item=file_path,
                    error=e,
                    batch_info={
                        "attempts": attempt,
                        "max_retries": max_retries
                    }
                )
                logger.error(error_msg)
                return {"success": False, "error": error_msg}

            # 重試前等待
            wait_time = 2 ** attempt  # 指數退避
            logger.warning(
                f"嘗試 {attempt}/{max_retries} 失敗，{wait_time}秒後重試..."
            )
            await asyncio.sleep(wait_time)

# 使用
result = await resilient_analyze("UserController.java", max_retries=3)
```

---

## 自訂錯誤處理

### 建立自訂異常類別

```python
from sdk_agent.exceptions import SDKAgentError
from sdk_agent.error_formatter import ErrorFormatter

class AnalysisTimeoutError(SDKAgentError):
    """分析逾時錯誤"""

    def __init__(self, file_path: str, timeout: int):
        error_msg = ErrorFormatter.format_error_message(
            error_type="AnalysisTimeoutError",
            component="analyzer",
            details=f"分析逾時（超過 {timeout} 秒）",
            context={
                "file_path": file_path,
                "timeout_seconds": timeout
            },
            suggestions=[
                f"增加逾時時間（目前: {timeout}秒）",
                "檢查檔案大小是否過大",
                "確認網路連線穩定"
            ]
        )
        super().__init__(error_msg)
        self.file_path = file_path
        self.timeout = timeout

# 使用
try:
    result = await analyze_with_timeout("LargeController.java", timeout=30)
except AnalysisTimeoutError as e:
    print(f"錯誤: {e}")
    print(f"檔案: {e.file_path}, 逾時: {e.timeout}秒")
```

### 錯誤處理裝飾器

```python
from functools import wraps
from sdk_agent.error_formatter import ErrorFormatter
import logging

logger = logging.getLogger(__name__)

def handle_errors(component: str):
    """錯誤處理裝飾器"""

    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)

            except Exception as e:
                error_msg = ErrorFormatter.format_error_message(
                    error_type=type(e).__name__,
                    component=component,
                    details=f"執行 {func.__name__} 時發生錯誤",
                    context={
                        "function": func.__name__,
                        "args": str(args),
                        "kwargs": str(kwargs),
                        "error": str(e)
                    },
                    suggestions=[
                        "查看詳細日誌",
                        "確認輸入參數正確",
                        "檢查系統資源"
                    ]
                )
                logger.error(error_msg)
                raise type(e)(error_msg) from e

        return wrapper
    return decorator

# 使用
@handle_errors(component="file_analyzer")
async def analyze_file(file_path: str):
    """分析檔案"""
    # ... 實作 ...
    pass
```

---

## 故障排除

### 問題 1: 上下文未顯示

**症狀：** 錯誤訊息中沒有 Context 區塊

**原因：** context 參數不是字典

**解決方案：**

```python
# ❌ 錯誤
context = "some string"

# ✅ 正確
context = {"key": "value"}
```

### 問題 2: 建議未顯示

**症狀：** 錯誤訊息中沒有 Suggestions 區塊

**原因：** suggestions 參數不是列表

**解決方案：**

```python
# ❌ 錯誤
suggestions = "Try this"

# ✅ 正確
suggestions = ["Try this", "And this"]
```

### 問題 3: 上下文被截斷

**症狀：** 上下文值顯示 `... [truncated]`

**原因：** 上下文值超過限制（500 字元）

**解決方案：**

```python
# 方案 1: 減少資料量
context = {
    "file_size": len(file_content),
    "first_100_chars": file_content[:100],
    "encoding": "utf-8"
}

# 方案 2: 增加限制
error_msg = ErrorFormatter.format_error_message(
    ...,
    context=large_context,
    max_context_value_length=2000,  # 增加到 2000
    max_total_context_length=10000  # 增加到 10000
)

# 方案 3: 停用截斷（僅用於除錯）
error_msg = ErrorFormatter.format_error_message(
    ...,
    context=large_context,
    max_context_value_length=-1,
    max_total_context_length=-1
)
```

### 問題 4: 日誌中出現大量錯誤

**症狀：** 日誌檔案快速增長，充滿錯誤訊息

**原因：** 錯誤處理不當，重複記錄相同錯誤

**解決方案：**

```python
# ❌ 不好：重複記錄
try:
    result = await process()
except Exception as e:
    logger.error(str(e))  # 記錄 1
    log_structured_error(logger, e, "comp")  # 記錄 2 (重複！)
    raise

# ✅ 好：只記錄一次
try:
    result = await process()
except Exception as e:
    log_structured_error(logger, e, "component", context)
    raise  # 不要再記錄

# ✅ 更好：在最外層統一處理
try:
    result = await complex_operation()
    return result
except Exception as e:
    # 只在最外層記錄錯誤
    log_structured_error(logger, e, "main", context)
    return {"success": False, "error": str(e)}
```

---

## 測試錯誤訊息

確保錯誤訊息格式正確：

```python
import pytest
from sdk_agent.error_formatter import ErrorFormatter

def test_error_message_format():
    """測試錯誤訊息格式正確"""
    error_msg = ErrorFormatter.format_validation_error(
        field_name="batch_size",
        value=0,
        expected="必須 >= 1"
    )

    # 檢查格式
    assert "[ValidationError]" in error_msg
    assert "batch_size" in error_msg
    assert "Context:" in error_msg
    assert "provided: 0" in error_msg
    assert "expected: 必須 >= 1" in error_msg

def test_file_error_format():
    """測試檔案錯誤格式"""
    error_msg = ErrorFormatter.format_file_error(
        file_path="test.java",
        error=FileNotFoundError("File not found"),
        operation="read"
    )

    assert "[FileNotFoundError]" in error_msg
    assert "file_operation" in error_msg
    assert "test.java" in error_msg
    assert "Suggestions:" in error_msg

def test_context_truncation():
    """測試上下文截斷"""
    large_value = "x" * 1000

    error_msg = ErrorFormatter.format_error_message(
        error_type="Error",
        component="test",
        details="Test",
        context={"large": large_value}
    )

    assert "truncated" in error_msg
    assert len(error_msg) < len(large_value)
```

---

## API 參考

### ErrorFormatter 類別

#### `format_error_message()`

通用錯誤格式化器。

**參數：**
- `error_type: str` - 錯誤類型名稱
- `component: str` - 發生錯誤的元件
- `details: str` - 錯誤詳細說明
- `context: Optional[ErrorContext]` - 上下文資訊（預設: None）
- `suggestions: Optional[SuggestionList]` - 修復建議（預設: None）
- `max_context_value_length: int` - 單一值最大長度（預設: 500，-1 = 停用）
- `max_total_context_length: int` - 總長度限制（預設: 2000，-1 = 停用）

**回傳：** `str` - 格式化的錯誤訊息

#### `format_file_error()`

格式化檔案操作錯誤。

**參數：**
- `file_path: str` - 檔案路徑
- `error: Exception` - 發生的異常
- `operation: str` - 操作類型（如 "read"、"write"）
- `suggestions: Optional[SuggestionList]` - 自訂建議（預設: None）

**回傳：** `str` - 格式化的錯誤訊息

#### `format_validation_error()`

格式化驗證錯誤。

**參數：**
- `field_name: str` - 驗證失敗的欄位名稱
- `value: Any` - 提供的無效值
- `expected: str` - 預期值的說明
- `suggestions: Optional[SuggestionList]` - 修復建議（預設: None）

**回傳：** `str` - 格式化的錯誤訊息

#### `format_configuration_error()`

格式化設定參數錯誤。

**參數：**
- `parameter: str` - 參數名稱
- `value: Any` - 無效值
- `valid_range: str` - 有效範圍或值的說明
- `suggestions: Optional[SuggestionList]` - 修復建議（預設: None）

**回傳：** `str` - 格式化的錯誤訊息

#### `format_processing_error()`

格式化批次處理錯誤。

**參數：**
- `item: str` - 正在處理的項目
- `error: Exception` - 發生的異常
- `batch_info: Optional[ErrorContext]` - 批次上下文資訊（預設: None）

**回傳：** `str` - 格式化的錯誤訊息

### 輔助函數

#### `log_structured_error()`

使用結構化格式記錄錯誤。

**參數：**
- `logger_obj: logging.Logger` - Logger 實例
- `error: Exception` - 要記錄的異常
- `component: str` - 發生錯誤的元件
- `context: Optional[ErrorContext]` - 上下文資訊（預設: None）
- `level: int` - 日誌層級（預設: logging.ERROR）

**回傳：** `None`

### 型別別名

```python
ErrorContext = Dict[str, Any]      # 上下文字典
SuggestionList = List[str]         # 建議列表
```

### 常數

```python
MAX_CONTEXT_VALUE_LENGTH = 500     # 單一值最大長度
MAX_TOTAL_CONTEXT_LENGTH = 2000    # 總長度限制
```

---

## 相關資源

📚 **相關文檔：**
- [使用手冊](./使用手冊.md) - 完整功能說明
- [SDK 代理模式](./SDK代理模式指南.md) - 雙向對話模式
- [最佳實踐](./最佳實踐.md) - 進階技巧

🆘 **需要幫助：**
- [常見問題](./常見問題.md)
- [故障排除](./故障排除.md)
- [GitHub Issues](https://github.com/yourusername/springmvc-agent-analyzer/issues)

---

**上一篇：** [← SDK 代理模式指南](./SDK代理模式指南.md)
**下一篇：** [最佳實踐 →](./最佳實踐.md)
